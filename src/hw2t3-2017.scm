(define (expr->ext e) e)

(define (symbol->func s)
    (cond
        ((eqv? '+ s) +)
        ((eqv? '- s) -)
        ((eqv? '* s) *)
        ((eqv? '/ s) /)
        ((eqv? 'expt s) expt)
        (else s)
    )
)

(define (eval-ext t x)
    (cond
        ((eqv? 'x t) x)
        ((number? t) t)
        (else ((symbol->func (car t)) (eval-ext (car (cdr t))) (eval-ext (car (cdr (cdr t))))))
    )
)

(define (split-ext f t)
    (f (car t) (car (cdr t)) (car (cdr (cdr t))))
)

(define (ext-op-normal-form t)
    (if (list? t)
        (split-ext (lambda (s f g)
            (cond
                ((eqv? '- s) (list '+ (ext-op-normal-form f) (if (number? g) (- g) (list '* -1 (ext-op-normal-form g)))))
                ((eqv? '-/ s) (list '* (ext-op-normal-form f) (if (number? g) (/ 1 g) (list '/ 1 (ext-op-normal-form g)))))
                (else (list s (ext-op-normal-form f) (ext-op-normal-form g)))
            )
        ) t)
        t
    )
)

(define (ext-number-normal-form t)
    (if (list? t)
        (split-ext (lambda (s f g) (
            (lambda (f g) 
                (if (and (number? f) (number? g))
                    ((symbol->func s) f g)
                    (if (number? g) (list s g f) (list s f g))  
                )
            ) (ext-number-normal-form f) (ext-number-normal-form g))
        ) t)
        t
    )
)

(define (eqv-ext? t1 t2)
    (cond
        ((and (number? t1) (number? t2)) (eqv? t1 t2))
        ((and (list? t1) (list? t2))
            (split-ext (lambda (s1 f1 g1)
                (split-ext (lambda (s2 f2 g2)
                    (and (eqv? s1 s2) (or
                        (and (eqv-ext? f1 f2) (eqv-ext? g1 g2))
                        (and (eqv-ext? f1 g2) (eqv-ext? g1 f2))
                    ))
                ) t2)
            ) t1)       
        )
        (else (eqv? t1 t2))    
    )
)

(define (ext-simplify-number-after-op-normal-form t)
    (if (list? t)
        (split-ext (lambda (s f g)
            (if (and (number? f) (number? g))
                ((symbol->func s) f g)
                ((lambda (h f g) (if (number? g) (h g f) (h f g))) (lambda (f g)
                    (cond
                        ((and (number? f) (list? g) (eqv? s (car g)) (number? (car (cdr g))))
                            (split-ext (lambda (s num t2)
                                (ext-simplify-number-after-op-normal-form (list s ((symbol->func s) f num) t2))
                            ) g)
                        )
                        ((and (not (number? f)) (list? g) (eqv? s (car g)) (number? (car (cdr g))))
                            (split-ext (lambda (s num t2)
                                (ext-simplify-number-after-op-normal-form (list s num (list s t2 f)))
                            ) g)
                        )
                        ((eqv? '+ s)
                            (cond
                                ((and (number? f) (= 0 f)) g)
                                ((eqv-ext? f g)
                                    (ext-simplify-number-after-op-normal-form (list '* 2 f))
                                )
                                (else (list s f g))
                            )
                        )
                        ((eqv? '* s)
                            (cond
                                ((number? f)
                                    (cond
                                        ((= 0 f) 0)
                                        ((= 1 f) g)
                                        (else (list s f g))    
                                    )
                                )
                                (else (list s f g))
                            )
                        )
                        (else (list s f g))
                    )
                ) (ext-simplify-number-after-op-normal-form f) (ext-simplify-number-after-op-normal-form g))
            ) 
        ) t)
        t
    )
)

(define (ext-simplify t)
    (ext-simplify-number-after-op-normal-form (ext-number-normal-form (ext-op-normal-form t)))
)

(define (direct-ext-derive t)
    (cond
        ((eqv? 'x t) 1)
        ((number? t) 0)
        (else (split-ext (lambda (s f g)
            (cond
                ((or (eqv? '+ s) (eqv? '- s)) (list s (direct-ext-derive f) (direct-ext-derive g)))
                ((eqv? '* s) (list '+ (list '* (direct-ext-derive f) g) (list '* f (direct-ext-derive g))))
                ((eqv? '/ s) (list '/ (list '+ (list '* (direct-ext-derive f) g) (list '* f (direct-ext-derive g))) (list '* g g)))
                (else #f)
            )
        ) t))
    )
)

(define (ext-derive t) (ext-simplify (direct-ext-derive (ext-simplify  t))))

(ext-derive '(* (* (* x (* x 2)) 3) 2))

; (load "hw2t3-2017.scm")